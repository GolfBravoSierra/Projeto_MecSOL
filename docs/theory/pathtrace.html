
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Path-Following Algorithm &#8212; TrussPy 2018.08 documentation</title>
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2018.08',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Code Structure" href="../code_structure/structure.html" />
    <link rel="prev" title="Modified system equations" href="modified.html" />
    <link rel="canonical" href="http://www.sphinx-doc.org/en/master/theory/pathtrace.html" />

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
  <body>
<div class="pageheader">
    <div >
        <a href="https://github.com/you"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png" alt="Fork me on GitHub"></a>
    </div>
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="../usage/install.html">Get it</a></li>
    <li><a href="../usage/getting_started.html">Quickstart</a></li>
    <li><a href="theory.html">Theory Guide</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/sphinxheader.png" alt="TRUSSPY" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../code_structure/structure.html" title="Code Structure"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modified.html" title="Modified system equations"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Home</a>&#160;|</li>
        <li><a href="../usage/getting_started.html">Quickstart</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="theory.html" accesskey="U">Theory Guide</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="modified.html"
                        title="previous chapter">Modified system equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../code_structure/structure.html"
                        title="next chapter">Code Structure</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="path-following-algorithm">
<h1>Path-Following Algorithm<a class="headerlink" href="#path-following-algorithm" title="Permalink to this headline">¶</a></h1>
<p>This section gives an overview of the algorithm for the path-following <a class="reference internal" href="../api/trusspy.solvers.tpsolver.html#trusspy.solvers.tpsolver.pathfollow" title="trusspy.solvers.tpsolver.pathfollow"><code class="xref py py-func docutils literal"><span class="pre">trusspy.solvers.tpsolver.pathfollow()</span></code></a> of the equilibrium curve. The algorithm is called once for each step, which contains solutions for a number of increments. During an increment several Newton-Rhapson (NR) iterations are performed to obtain a fullfilled equilibrium. For an easier understanding this description uses a mixed Python and pseudo-code style with omitting namespaces, etc.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>+ step 1                # &lt;-- path-following algorithm is called the first time
  - increment 1
      * iteration 1
      * iteration 2
      * iteration 3
      * ...
      * iteration n
  - incrmeent 2
      * iteration 1
      * iteration 2
      * iteration 3
      * ...
      * iteration n

+ step 2                # &lt;-- path-following algorithm is called the 2-nd time
+ ...
+ step s                # &lt;-- path-following algorithm is called the s-th time
</pre></div>
</div>
<div class="section" id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<p>Some initializations have to be made before the calculation loops may start. First, there is a init section for the <em>step</em> followed by an initialization for each <em>increment</em>. If the user doesn’t freeze the control component for the whole analysis, the control component is initialized to the incremental load-proportionality-factor <cite>dlpf</cite> which is the last component in <cite>x</cite>.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>If we use the automatic incremental stepwidth control (has <strong>absolutely nothing</strong> to do with the <em>global</em> step) a internal variable is pre-defined for later use. This will ensure a stepwidth increase is only performed if the previous <cite>b</cite> increments were successfully solved within the specified number of iterations and without any recycles.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="section" id="increment-loop">
<h2>Increment Loop<a class="headerlink" href="#increment-loop" title="Permalink to this headline">¶</a></h2>
<p>For each increment several recycles <cite>z</cite> are allowed. The amount of recycle loops is controlled with the <cite>cycl</cite> parameter and defaults to <cite>cycl=4</cite>. The system vector <cite>x</cite> is copied to <cite>x0</cite> so we can go back to the initial system vector if a recycle will be necessary.</p>
<div class="section" id="initialization-determination-of-the-control-component-j">
<h3>Initialization - Determination of the control component <cite>j</cite><a class="headerlink" href="#initialization-determination-of-the-control-component-j" title="Permalink to this headline">¶</a></h3>
<p>A success flag for the pre - NR-iteration is initiated to <cite>False</cite>. The amount of NR-iterations is limited to 1, as we are interested only in the linear solution of the equilibrium equations. Note that it is important to know the direction of the incremental LPF to determine the direction for the upcoming equilibrium state. Is it always positive? No! So we’ll use the determinant of the global stiffness matrix at the given state <cite>x</cite> (beginning of the increment) to get the direction information. As we are not yet interested in the control equation - or, with other - we don’t know it yet, we just omit the last dimensions by slicing the matrix <cite>dfdx(x`*args)[:-1,:-1]</cite>.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">sgn</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span> <span class="n">det</span><span class="p">(</span> <span class="n">dfdx</span><span class="p">(</span><span class="n">x</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="n">j</span>   <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">sgn</span>
</pre></div>
</div>
<p>The absolute scalar-valued control parameter for the pre - NR-iteration is further determined as <cite>xmax = x[j] + dxmax[j]</cite>. As Python is indexing arrays with starting <cite>0</cite> we have to take care to get the right value and subtract j by 1 in the component selection. The solution for the pre-identification is then performed with a single NR-iteration.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">xmax</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dxmax</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sign</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
<span class="n">solution_pre</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">dfdx</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">nfev_pre</span><span class="p">,</span><span class="n">ftol</span><span class="p">,</span><span class="n">xtol</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">solution_pre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nr_success_pre</span> <span class="o">=</span> <span class="n">sultion_pre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Dx</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">x0</span>
</pre></div>
</div>
<p>As we are interested in the incremental <cite>Dx</cite> and not the absolute <cite>x</cite> vector we build the difference. (OK, this is unnecessary but easier to code). Now we look for the biggest componenet in Dx and it’s sign. Both informations are stored inside the single variable <cite>j</cite>. Again, taking care of Python’s 0-indexing.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="p">(</span><span class="n">Dx</span><span class="p">,</span><span class="nb">max</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sign</span><span class="p">(</span><span class="n">Dx</span><span class="p">,</span><span class="nb">max</span><span class="p">)</span>
</pre></div>
</div>
<p>What we got so far is:</p>
<ul class="simple">
<li>determination of the control component <cite>j</cite> and</li>
<li>corresponding solution <cite>x</cite>.</li>
</ul>
<p>If the solution did converge in this single increment, then the increment is finished. This is indicated by the success flag <cite>nr_success_pre</cite>. Increment results are copied to <a class="reference internal" href="../api/trusspy.core.analysis.html#trusspy.core.analysis.Analysis" title="trusspy.core.analysis.Analysis"><code class="xref py py-class docutils literal"><span class="pre">trusspy.core.analysis.Analysis</span></code></a> - go to next increment.</p>
</div>
<div class="section" id="recycle-loop-nonlinear-solution-process">
<h3>Recycle Loop (Nonlinear solution process)<a class="headerlink" href="#recycle-loop-nonlinear-solution-process" title="Permalink to this headline">¶</a></h3>
<p>If the pre NR-iteration did not converge (<cite>nr_success_pre = False</cite>) a recycle loop is started. For later usage the current control component <cite>j</cite> is copied to <cite>j0</cite>. Also, we reset the system vector <cite>x</cite> to <cite>x0</cite>. Before the NR-iterations <a class="reference internal" href="../api/trusspy.solvers.zerosearch.html#trusspy.solvers.zerosearch.newton" title="trusspy.solvers.zerosearch.newton"><code class="xref py py-func docutils literal"><span class="pre">trusspy.solvers.zerosearch.newton()</span></code></a> are called the allowed control component <cite>xmax</cite> is updated with the current values of <cite>j</cite> and <cite>dxmax</cite>.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">nr_success_pre</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">j0</span> <span class="o">=</span> <span class="n">j</span>

    <span class="n">xmax</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dxmax</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span><span class="n">nr_success</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">f_norm</span><span class="p">,</span><span class="n">x_norm</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">dfdx</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">nfev</span><span class="p">,</span><span class="n">ftol</span><span class="p">,</span><span class="n">xtol</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">Dx</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">x0</span>
</pre></div>
</div>
<p>The total incremental system vector is then obtained by the difference between the end and beginning state of the increment (or, alternatively as a sum over all virtual NR-iteration solutions <cite>Dx = sum(dx)</cite> ). If the solution has met our tolarences we stop the recycle loop, call the equilibrium function <cite>f(x)</cite> once again with a flag to store internal variables inside the material definition, append the analysis <a class="reference internal" href="../api/trusspy.core.analysis.html#trusspy.core.analysis.Analysis" title="trusspy.core.analysis.Analysis"><code class="xref py py-class docutils literal"><span class="pre">trusspy.core.analysis.Analysis</span></code></a> to <a class="reference internal" href="../api/trusspy.handlers.handler_result.html#trusspy.handlers.handler_result.ResultHandler" title="trusspy.handlers.handler_result.ResultHandler"><code class="xref py py-class docutils literal"><span class="pre">trusspy.handlers.handler_result.ResultHandler</span></code></a> and proceed to the next increment. Otherwise, when the used and final control component differ each other, once again recycle is performed. Therefore the recycle variable is increased <cite>z = z+1</cite>. The final control component will be used for the recycle of the increment. This procedure is done not more than <cite>cycl</cite> times as long as the control component does not change anymore and the required tolerances are met. Otherwise the calculation stops.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../code_structure/structure.html" title="Code Structure"
             >next</a> |</li>
        <li class="right" >
          <a href="modified.html" title="Modified system equations"
             >previous</a> |</li>
        <li><a href="../index.html">Home</a>&#160;|</li>
        <li><a href="../usage/getting_started.html">Quickstart</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="theory.html" >Theory Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Trusspy.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>